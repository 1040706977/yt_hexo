

[TOC]

## 表示字符串I/O

字符串是以空字符`\0`结尾的char类型数组，因此可以应用指针表示法或者数组表示法。

另外由于字符串十分常用，所以 C提供了许多专门用于处理字符串的函数。例如：puts()

但与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。



### 在程序中定义字符串

分别使用如下定义字符串：字符串常量、char类型数组、指向char的指针

```C
#define　MSG　"I　am　a　symbolic　string　constant."
...
char　words[MAXLENGTH]　=　"I　am　a　string　in　an　array.";
const char * pt1 = "Something is pointing at me.";
```

#### （1）字符串字面量（字符串常量）

ANSI C标准开始，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为==串联==起来的字符串字面量。与下面代码等价`char greeting[50] = "Hello, and how are you today!";`

```C
    char greeting[50] = "Hello, and" " how" "are you"
                                           " today?";
    printf("%s\n", greeting);	// 输出Hello, and howare you today?
```

- 用指针来指向字符串字面量

字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。==用双引号括起来的内容**被视为**指向该字符串储存位置的**指针**==。这类似于把数组名作为指向该数组位置的指针。

```C
printf("%s, %p, %c\n", "We", "are", *"space farers");// 输出We, 00007ff629c4a004, s 
----------------------------------------------------------------------------------
const char *p1 = "space farers";	// *"space farers"表示该字符串首元素的内存地址值
const char *p2;
p2 = "space farers";				// 字符串“space farers”被视为指针
printf("%c\n", *(p1 + 1));			// 输出p
printf("%c\n", *(p2 + 2));			// 输出a
```

#### （2）字符串数组和初始化

定义字符串数组时，必须让编译器知道需要多少空间。

一种方法是用足够空间的数组储存字符串，此时所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符`'\0'`，不是数字字符`'0'`

```C
const char m1[16] = "Hello";					// 定义字符串数组m1
const char m2[16] = {'H','e','l','l','o','\0'};	// 定义字符串数组m2
const char m3[16] = {'H','e','l','l','o'};		// 定义字符数组m3
// 注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。
```

- 只有字符串数组可以直接使用字符串相关函数

首先，字符串数组是以'\0'结尾的字符序列，所以最后一个元素必须是'\0'，表示字符串的结束。

因此，在指定字符串数组大小时，要确保数组的元素个数==至少==比字符串长度多1（为了容纳空字符）

最后，==字符串数组可以使用一系列字符串相关函数==，例如strlen、strcpy、strcat等，方便对字符串进行操作；而字符数组则需要手动实现这些操作。

- 编译器确定数组的大小

让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串在何处结束。

```C
int　n　=　8;
char crumbs[n];　　　　 // C99标准之前无效，C99标准之后这种数组是变长数组
char cakes[2 + 5];	   // 有效，数组大小是整型常量表达式
char pies[2*sizeof(long double) + 1]; 	// 有效
```

- 使用字符串数组的数组名

假设有初始化：`char car[] = "Tata";`那么，以下表达式都为真：

```C
printf("%d\n", car == &car[0] );		// 1
printf("%d\n", *car == 'T');			// 1
printf("%d\n", *(car + 1) == car[1]);	// 1
printf("%d\n", *car == *"Tata");    	// 1，注意car和"Tata"是指向相同的不同指针
```

```C
printf("%p %p\n", car, *car );			// 000000e3783ff8bc 0000000000000054
printf("%p %p\n", "Tata", *"Tata");		// 00007ff7a498b00b 0000000000000054
printf("%c\n",*(++car));				// 错误！  在数组形式中，car是地址常量！
printf("%c\n",*(car+2));				// t
*car = 'D';		printf("%c\n",*car);	// D
```

当然也可使用：`const char *car = "Tata";`和上面的声明几乎相同，==但是有一点不一样！！==

```C
printf("%d\n", car == &car[0] );		// 1
printf("%d\n", *car == 'T');			// 1
printf("%d\n", *(car + 1) == car[1]);	// 1
printf("%d\n", *car == *"Tata");    	// 1，注意car和"Tata"是同一个的指针！！
```

```C
printf("%p %p\n", car, *car );			// 00007ff6732cb000 0000000000000054
printf("%p %p\n", "Tata", *"Tata");		// 00007ff6732cb000 0000000000000054
printf("%c\n",*(++car));				// a
printf("%c\n",*(car+2));				// t
*car = 'D';		printf("%c\n",*car);	// 错误！car为指向const的指针，不能修改数据
```

在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。

#### （3）数组和指针

数组形式和指针形式有何不同？以上面的声明为例

- 数组形式car[]

通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区中（static memory）。但是，程序在开始运行时才会为该数组分配内存时才将字符串拷贝到数组（dynamic memory）。此时，字符串有两个副本：

1. **静态内存中的字符串字面量**
2. **储存在car数组中的字符串副本**。

此后，编译器便把数组名car识别为该数组首元素地址（&ar1[0]）的别名。这里关键要理解，==在数组形式中，car是地址常量==。不能更改car，如果改变了car，则意味着改变了数组的存储位置（即地址）。可以进行类似car+1这样的操作，标识数组的下一个元素。但是不允许进行++car这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。

- 指针形式*car

指针形式（*car）也使得编译器为字符串在静态存储区预留5个元素的空间（包括'\0'）。另外，一旦开始执行程序，它会为指针变量car留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，++car将指向第2 个字符（a）。

- 字符串字面量被视为const数据。

==由于car指向const类型的字符串字面量，所以应该把car声明为指向const类型的指针==。这意味着不能用car改变它所指向的数据，不过仍然可以改变car指向的位置。

如果把一个字符串字面量拷贝给一个非const的数组，就可以随意改变数据，除非把数组声明为const（例如`const char car[] = 'Tata'`）

>初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。
>
>数组和指针表示字符串的区别是否很重要？通常不太重要，但是这取决于想用程序做什么。

#### （4）数组和指针的区别

- 初始化字符数组来储存字符串和初始化指针来指向字符串有何区别？

```C
char heart[] = "I love Tillie!";
const char *head = "I love Millie!";
```

两者主要的区别是：

1. heart是常量，而head是变量。
2. heart是普通指针，而head是指向const的指针。

- 不推荐使用char *car = 'Tada'

编译器可能允许这样做，但是对当前的C标准而言，这样的行为是未定义的。例如，这样的语句可能导致内存访问错误，因为编译器使用内存中的一个副本来表示所有完全相同的字符串字面量。

```C
char * p1 = "Klingon";
p1[0] = 'F'; // ok?
printf("Klingon");
printf(": Beware the %ss!\n", "Klingon");
```

编译器可以用相同的地址替换每个"Klingon"实例。如果编译器使用这种单次副本表示法，并允许p1[0]修改'F'，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量"Klingon"时实际上显示的
是"Flingon"：`Flingon: Beware the Flingons!`

>因此，建议在把指针初始化为字符串字面量时使用const限定符。
>
>总之，如果不全局修改字符串，不要用指针指向字符串字面量。

#### （5）字符串数组

指向字符串的指针数组和char类型数组的数组。

```C
#define COL 40
#define ROW 4
int main() {
    char s[ROW][COL] = {"Hello", "the" , "world", "!"};
    const char *t[COL] = {"Hello", "the" , "world", "!"};
    printf("%-20s %-20s\n",s[0], t[2]);						// Hello      world
```

- 占用空间不同

s是一个内含4个数组的数组，占用160个字节。

t是一个内含4个指针的数组，占用32个字节；

- 内存位置不同

s中的是字符串字面量的副本，原始字符串字面量在静态内存中。

t中的就是字符串字面量本身。

- 内存效率不同

字符串数组分配内存的使用率较低。

s中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。

s中的元素属于数组，因此必须内存上连续，而t则没有内存连续性要求。

- 是否能修改

s可以修改，因为s只是个普通的二维数组啊

t不能修改，因为t是指向const字符串的指针

>如果，要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。
>
>但是，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。



### 指针和字符串

读者可能已经注意到了，在讨论字符串时或多或少会涉及指针。

实际上，字符串的绝大多数操作都是通过指针完成的。

```C
const char * mesg = "Don't be a fool!";
const char * copy;
copy　=　mesg;
```

你可能认为该程序拷贝了字符串"Don't be a fool!"，但是其实只拷贝了指针：

```C
printf("mesg　=　%s;　&mesg　=　%p;　value　=　%p\n",　mesg,　&mesg,　mesg);
// mesg　=　Don't　be　a　fool!;　&mesg　=　0x0012ff48;　value　=　0x0040a000
printf("copy　=　%s;　&copy　=　%p;　value　=　%p\n",　copy,　&copy,　copy);
// copy　=　Don't　be　a　fool!;　&copy　=　0x0012ff44;　value　=　0x0040a000
```

为什么要这样做？为何不拷贝整个字符串？考虑一下哪种方法更效率：

拷贝一个地址还是拷贝整个数组？通常，==程序要完成某项操作只需要知道地址就可以了==。如果确实需要拷贝整个数组，可以使用strcpy()或strncpy()函数。





## 字符串输入

如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。

### 分配空间

最简单的方法是，在声明时显式指明数组的大小：`char name[81];`

还有一种方法是使用C库函数来分配内存，第12章会讲。

### gets()

scanf()和转换说明%s只能读取一个单词，但是程序中经常要读取一整行输入。

```C
int puts(const char *_Str)
char *gets(char *_Buffer) 
```

gets()函数简单易用，它读取整行输入，遇到并丢弃换行符，最后在末尾添加空字符`'\0'`。

puts()函数配对使用，该函数用于显示一个 C 字符串，会在末尾添加换行符`'\t'`

```C
#define LENGTH 255
...
char words[LENGTH];
puts("Enter a string, please...");
gets(words);						// gets()函数会从Buffer中读取字符串
puts(words);
```

- 缓冲区溢出

gets()唯一的参数是 words，它无法检查数组是否装得下输入行。

gets()函数只知道数组的开始处，并不知道数组中有多少个元素。

如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止：`Process finished with exit code -1073741819 (0xC0000005)`

- 废除gets()函数

好景不长，C11标准委员会采取了更强硬的态度，直接从标准中废除了gets()函数。

### gets()的替代品

1. 过去通常用`fgets()`来代替gets()，使用更加复杂
2. C11标准新增的`gets_s()`函数也可代替gets()，而且可以替换现有代码中的gets()

>但是，gets_s()是stdio.h输入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。

#### fgets()

```C
int fputs(const char *_Str, _iobuf *_File)
char *fgets(char *_Buf, int _MaxCount, _iobuf *_File)
```

fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入`n - 1`个字符，或者读到遇到第一个换行符为止。

>fgets()读到换行符时：
>
>（1）如果此时（已读取的字符数量 + 1）< _Maxcount，就会把'\n'储存在字符串中！然后再加上字符串结束符'\0'，这个和gets()不一样。
>
>（2）如果此时（已读取的字符数量 + 1）= _Maxcount，没有位置存放换行符'\n'了。

```C
#define COL 7
...
    char words[COL];
    fputs("Enter a string, please: ", stdout);
    fgets(words, COL, stdin);
    for (int i = 0; i < COL; ++i) {
        printf("%d\t", words[i]);
    }
```

```C
Enter a string, please: 123456
49      50      51      52      53      54      0
--------------------------------------------------
Enter a string, please: 12345
49      50      51      52      53      10      0
```

fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin作为参数。

>fputs()函数不会在末尾添加换行符'\n'，这个和puts()也不一样。	

- fputs()函数返回指向char的指针

如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。

如果函数读到文件结尾，它将返回一个特殊的指针：空指针（null pointer）。

```C
int main() {
    char words[LEN];
    puts("Enter strings (empty line to quit):");
    while (fgets(words, LEN, stdin) != NULL &&
           words[0] != '\n') {
        fputs(words, stdout);
    }
    puts("Done.");
    return 0;
}
```

虽然STLEN被设置为10，但是该程序似乎在处理过长的输入时完全没问题，原因如下：

程序中的fgets()一次读入 `STLEN - 1 `个字符。所以，第一次它只读入了“By the wa”，并储存为By the wa\0；接着fputs()打印该字符串，而且并未换行。然后while循环进入下一轮迭代，fgets()继续从剩余的输入中读入数据，第二次它读入“y, the ge”并储存为y, the ge\0；接着fputs()在刚才打印字符串。直到第三次读入最后的“tion\n”。fgets()将其储存为tion\n\0， fputs()打印该字符串，由于字符串中的\n，光标被移至下一行开始处。

- 系统使用缓冲I/O

在缓冲I/O中，输入和输出都被存储在缓冲区中，而不是直接读写文件或设备。这样可以减少I/O操作的次数，从而提高效率。

对于输入，当用户输入字符时，这些字符会被存储在缓冲区中，直到用户按下Return键。此时，缓冲区中的所有字符都会被一次性读取，并传递给fgets()函数进行处理。

对于输出，当程序调用fputs()函数输出字符时，这些字符会被存储在缓冲区中，直到缓冲区满或者遇到换行符。此时，缓冲区中的所有字符都会被一次性输出到屏幕上。

 需要注意的是，缓冲I/O可能会导致数据不一致的问题。如果程序在输出数据之前崩溃或者异常退出，那么缓冲区中的数据可能会丢失。为了避免这种情况，可以使用fflush()函数强制刷新缓冲区，或者使用无缓冲I/O操作。

>fgets()储存换行符有好处也有坏处。
>
>坏处是你可能并不想把换行符储存在字符串中，这样的换行符会带来一些麻烦。
>
>好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行。如果不是一整行，要妥善处理一行中剩下的字符。

- 如何处理掉换行符

一个方法是在已储存的字符串中查找换行符，并将其替换成空字符：

```C
while (words[i] != '\n') // 假设\n在words中
	i++;
words[i]　=　'\0';
```

- 如果仍有字符串留在输入行怎么办？

一个可行的办法是，如果目标数组装不下一整行输入，就丢弃那些多出的字符：

```C
while (getchar() != '\n') // 读取但不储存输入，包括\n
	continue;
```



下面程序读取输入行，删除储存在字符串中的换行符，如果没有换行符，则丢弃数组装不下的字符。

```C
#define TLEN 10
int main(void) {
    char words[TLEN];
    int i;
    puts("Enter strings (empty line to quit):");
    while (fgets(words, TLEN, stdin) != NULL &&
           words[0] != '\n') {			// 输入未结束or首字符不是换行符
        i = 0;
        while (words[i] != '\n' && words[i] != '\0') {
            i++;						
        }

        if (words[i] == '\n') {
            words[i] = '\0';            // 遇到换行符
        } else if (words[i] == '\0') {
            while (getchar() != '\n')   // 
                continue;
        }
        puts(words);
    }
    puts("done");
    return 0;
}
```

- 空字符和空指针

空字符（或'\0'）是用于标记C字符串末尾的字符，其对应字符编码是0

空指针（或NULL）有一个值，该值不会与任何数据的有效地址对应。

空字符是一个字符，整数类型，占1字节；而空指针是一个地址，指针类型，通常占4字节。

#### gets_s()

- gets_s()与fgets()的区别

1. gets_s()只从标准输入stdin中读取数据，所以不需要第3个参数。

2. gets_s()如果读到换行符，会丢弃它而不是储存它。

3. gets_s()如读到最大字符数都没有读到换行符，会执行以下几步：首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会中止或退出程序。

- gets()、fgets()和 gets_s()的适用性

1. 如果目标存储区装得下输入行，3 个函数都没问题。但是fgets()会保留输入末尾的换行符作为字符串的一部分，要编写额外的代码将其替换成空字符。
2. 如果输入行太长，使用gets()不安全，它会擦写现有数据，存在安全隐患。gets_s()函数很安全，但是，如果并不希望程序中止或退出，就要知道如何编写特殊的“处理函数”。另外，如果打算让程序继续运行，gets_s()会丢弃该输入行的其余字符，无论你是否需要。由此可见，当输入太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择不同的处理方式。
